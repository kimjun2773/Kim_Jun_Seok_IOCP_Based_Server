# Kim_Jun_Seok_IOCP_Based_Server

IOCP 기반의 C++ TCP/IP Stateful 서버 프레임워크 입니다.

윈도우 환경에서 Visual Studio 2017 (v141) 툴셋 으로 빌드 하실 수 있습니다.



내부에 프로젝트는 세 개 이며 각자 

Project_Server -> 서버 바이너리

Project_Common -> 클라서버 공용 라이브러리

Project_Client -> 클라이언트 바이너리

가 빌드 됩니다.



구현한 동작은 단순히 루프백 주소에 대기중인 서버에 클라이언트가 접속하여

클라이언트의 로컬 채팅 메세지가 서버 바이너리 화면에 뜨고 클라이언트로 다시 보내는 에코 채팅 서버 입니다.

구현한 서버 프레임워크의 주요한 기능을 구현한 파일들 위주로 간략히 설명 하겠습니다.



Singleton.h
{
	템플릿 싱글턴 클래스 입니다.
	
	상속을 통해 원하는 클래스를 싱글턴으로 구현 할 수 있습니다.
	
	lazy evaluation 방식으로 동작하며 GetInstance 함수 호출시
	
	싱글턴 클래스의 생성자가 호출되므로 각 싱글턴 클래스들의 초기화 순서를 제어 할 수 있습니다.
} 

IOCP.h, IOCP.cpp -> 
{
	IOCP와 GQCS 워커 스레드를 래핑한 클래스 입니다. 
	
	IOCP클래스를 상속하여 ThreadMain함수를 커스터마이징 하여 사용합니다.
	
	구현한 프레임워크 내에서는 서버의 네트워크 레이어의 워커스레드로만 활용되고있지만,
	
	확장하면, 클라이언트내에서 리소스 로딩용 멀티스레드 액터로도 활용 할 수 있습니다.
}

IOCP_Message.h, IOCP_Message.cpp -> 
{
	IOCP GQCS 워커 스레드에서 주고 받는 메세지를 구현한 클래스입니다.
	
	OVERLAPPED 클래스를 상속했으며, 
	
	어떤 IO 동작인지를 규명하는 enum이 정의 되어있고,

	m_MessageType에 담아 보낼 수있습니다. 
	
	m_pOderer 멤버를 통해 비동기 IO 메세지를 송신한 주체를 알아낼수 있습니다. 
}

NetworkSystem.h, NetworkSystem.cpp -> 
{
	서버 프레임워크의 네트워크레이어를 표현한 클래스입니다.
	
	네트워크 IO 처리를 위해 IOCP 클래스를 상속 했으며 싱글턴으로 구현되어 있습니다.
	
	몇가지 특징으로는 워커 스레드는 4개, 동시에 최대 활성화되는 워크 스레드도 4개 입니다.
	
	또한 AcceptEx 함수를 사용하여 별도의 Accept 스레드가 따로 필요 없습니다.
}

Session.h, Session.cpp -> 
{
	서버 프레임 워크의 네트워크레이어 내에서 하나의 세션을 의미하는 클래스입니다.
	
	내부에 멤버로 Socket 핸들을 가지고 있으며
	
	구현한 세션의 특징으로는 Nagle Off, Zero Copy, No Linger 옵션을 적용 하였습니다.
}

AsemblyBuffer.h, AsemblyBuffer.cpp -> 
{
	송수신 할 데이터스트림을 컨텐츠 통신 단위인 패킷으로 조립 하기위한 버퍼 클래스 입니다.
}


Packet.h, Packet.cpp -> 
{
	송수신 할수 있는 컨텐츠의 데이터단위 입니다.
	
	각 컨텐츠 별로 Packet 클래스를 상속하여 사용합니다.
	
	현재 구현된 패킷은 채팅메세지 하나 뿐입니다.
}

ServerSystem.h, ServerSystem.cpp ->
{
	서버 프레임워크의 컨텐츠레이어를 표현한 클래스입니다.
	
	프로젝트 내에서 어디서즌 접근 가능하게 싱글턴으로 구현 하였고,
	
	네트워크 레이어에서 조립한 패킷을 수신하여 
	
	클라이언트의 컨텐츠 요청을 서비스 할 수 있습니다. 
}
